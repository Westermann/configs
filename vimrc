" the absolute crucial basics
filetype indent on
filetype plugin on
syntax on
let mapleader=","
set nocompatible
set tabstop=2
set shiftwidth=2
set expandtab
set smartindent
set hidden
set wildmenu
set showcmd
set hlsearch
nnoremap <C-L> :nohl<CR><C-L>
set ignorecase
set smartcase
set nostartofline
set ruler
set cmdheight=2
set number
set history=1000
set showmatch
" activate plugins
execute pathogen#infect()
" syntastic settings
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_aggregate_errors = 1
" Nvim-R settings
let R_in_buffer = 1
let R_close_term = 1
let R_rconsole_height = 35
" nerdtree settings
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
map <C-n> :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
" airline statusline
let g:airline_theme='simple'
" for python
autocmd FileType python map <LocalLeader>p :w<CR> :w !python %<CR>
" for r & rmarkdown
let g:syntastic_enable_r_lintr_checker = 1
au BufRead,BufNewFile *.Rmd set filetype=rmarkdown
autocmd FileType rmarkdown map <LocalLeader>r :w<CR> :RMarkdown pdf latex_engine="xelatex"<CR>
" use rmarkdown for normal markdown
au BufRead,BufNewFile *.md set filetype=rmarkdown
" for JavaScript
au BufRead,BufNewFile *.sjs set filetype=javascript
au BufRead,BufNewFile *.ms set filetype=javascript

" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool): true: Motion is exclusive
" false: Motion is inclusive
" fwd (bool): true: Go to next line
" false: Go to previous line
" lowerlevel (bool): true: Go to line with lower indentation level
" false: Go to line with the same indentation level
" skipblanks (bool): true: Skip blank lines
" false: Don't skip blank lines
function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
	let line = line('.')
	let column = col('.')
	let lastline = line('$')
	let indent = indent(line)
	let stepvalue = a:fwd ? 1 : -1
	while (line > 0 && line <= lastline)
		let line = line + stepvalue
		if ( ! a:lowerlevel && indent(line) == indent ||
					\ a:lowerlevel && indent(line) < indent)
			if (! a:skipblanks || strlen(getline(line)) > 0)
				if (a:exclusive)
					let line = line - stepvalue
				endif
				exe line
				exe "normal " column . "|"
				return
			endif
		endif
	endwhile
endfunction

" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<CR>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<CR>
vnoremap <silent> [l <Esc>:call NextIndent(0, 0, 0, 1)<CR>m'gv''
vnoremap <silent> ]l <Esc>:call NextIndent(0, 1, 0, 1)<CR>m'gv''
vnoremap <silent> [L <Esc>:call NextIndent(0, 0, 1, 1)<CR>m'gv''
vnoremap <silent> ]L <Esc>:call NextIndent(0, 1, 1, 1)<CR>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<CR>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<CR>
